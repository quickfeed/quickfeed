// @generated by protoc-gen-es v0.0.10 with parameter "target=ts"
// @generated from file patch/go.proto (package go, syntax proto2)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto2} from "@bufbuild/protobuf";

/**
 * Options represent Go-specific options for Protobuf messages, fields, oneofs, enums, or enum values.
 *
 * @generated from message go.Options
 */
export class Options extends Message<Options> {
  /**
   * The name option renames the generated Go identifier and related identifiers.
   * For a message, this renames the generated Go struct and nested messages or enums, if any.
   * For a message field, this renames the generated Go struct field and getter method.
   * For a oneof field, this renames the generated Go struct field, getter method, interface type, and wrapper types.
   * For an enum, this renames the generated Go type.
   * For an enum value, this renames the generated Go const.
   *
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * The embed option indicates the field should be embedded in the generated Go struct.
   * Only message types can be embedded. Oneof fields cannot be embedded.
   * See https://golang.org/ref/spec#Struct_types.
   *
   * @generated from field: optional bool embed = 2;
   */
  embed?: boolean;

  /**
   * The type option changes the generated field type.
   * All generated code assumes that this type is castable to the protocol buffer field type.
   *
   * @generated from field: optional string type = 3;
   */
  type?: string;

  /**
   * The getter option renames the generated getter method (default: Get<Field>)
   * so a custom getter can be implemented in its place.
   *
   * TODO: implement this
   *
   * @generated from field: optional string getter = 10;
   */
  getter?: string;

  /**
   * The tags option specifies additional struct tags which are appended a generated Go struct field.
   * This option may be specified on a message field or a oneof field.
   * The value should omit the enclosing backticks.
   *
   * @generated from field: optional string tags = 20;
   */
  tags?: string;

  /**
   * The stringer option renames a generated String() method (if any)
   * so a custom String() method can be implemented in its place.
   *
   * TODO: implement for messages
   *
   * @generated from field: optional string stringer = 30;
   */
  stringer?: string;

  /**
   * The stringer_name option is a deprecated alias for stringer.
   * It will be removed in a future version of this package.
   *
   * @generated from field: optional string stringer_name = 31;
   */
  stringerName?: string;

  constructor(data?: PartialMessage<Options>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "go.Options";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "embed", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 10, name: "getter", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 20, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 30, name: "stringer", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 31, name: "stringer_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Options {
    return new Options().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Options {
    return new Options().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Options {
    return new Options().fromJsonString(jsonString, options);
  }

  static equals(a: Options | PlainMessage<Options> | undefined, b: Options | PlainMessage<Options> | undefined): boolean {
    return proto2.util.equals(Options, a, b);
  }
}

/**
 * LintOptions represent options for linting a generated Go file.
 *
 * @generated from message go.LintOptions
 */
export class LintOptions extends Message<LintOptions> {
  /**
   * Set all to true if all generated Go symbols should be linted.
   * This option affects generated structs, struct fields, enum types, and value constants.
   *
   * @generated from field: optional bool all = 1;
   */
  all?: boolean;

  /**
   * Set messages to true if message names should be linted.
   * This does not affect message fields.
   *
   * @generated from field: optional bool messages = 2;
   */
  messages?: boolean;

  /**
   * Set messages to true if message field names should be linted.
   * This does not affect message fields.
   *
   * @generated from field: optional bool fields = 3;
   */
  fields?: boolean;

  /**
   * Set enums to true if generated enum names should be linted.
   * This does not affect enum values.
   *
   * @generated from field: optional bool enums = 4;
   */
  enums?: boolean;

  /**
   * Set values to true if generated enum value constants should be linted.
   *
   * @generated from field: optional bool values = 5;
   */
  values?: boolean;

  /**
   * Set extensions to true if generated extension names should be linted.
   *
   * @generated from field: optional bool extensions = 6;
   */
  extensions?: boolean;

  /**
   * The initialisms option lets you specify strings that should not be generated as mixed-case,
   * Examples: ID, URL, HTTP, etc.
   *
   * @generated from field: repeated string initialisms = 10;
   */
  initialisms: string[] = [];

  constructor(data?: PartialMessage<LintOptions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime = proto2;
  static readonly typeName = "go.LintOptions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "all", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 2, name: "messages", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "fields", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "enums", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 5, name: "values", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 6, name: "extensions", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 10, name: "initialisms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LintOptions {
    return new LintOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LintOptions {
    return new LintOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LintOptions {
    return new LintOptions().fromJsonString(jsonString, options);
  }

  static equals(a: LintOptions | PlainMessage<LintOptions> | undefined, b: LintOptions | PlainMessage<LintOptions> | undefined): boolean {
    return proto2.util.equals(LintOptions, a, b);
  }
}

